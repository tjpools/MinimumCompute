"""
Virtual Machine Emulator

This emulator runs the machine code generated by our assembler.
It simulates the CPU, memory, and I/O of our NAND-based computer.
"""

import sys
from typing import List


class VM:
    """Virtual Machine for NAND Compute."""
    
    def __init__(self, memory_size=256):
        # 8 general-purpose registers
        self.registers = [0] * 8
        
        # Memory (256 bytes)
        self.memory = [0] * memory_size
        
        # Program counter
        self.pc = 0
        
        # Flags
        self.zero_flag = False
        self.negative_flag = False
        
        # Control
        self.halted = False
        
        # Output buffer
        self.output = []
        
        # Instruction count (for debugging)
        self.instruction_count = 0
    
    def load_program(self, program: List[int], start_addr: int = 0):
        """Load program into memory."""
        for i, instruction in enumerate(program):
            if start_addr + i >= len(self.memory):
                break
            # Store 16-bit instruction as two bytes
            self.memory[start_addr + i * 2] = instruction & 0xFF
            self.memory[start_addr + i * 2 + 1] = (instruction >> 8) & 0xFF
    
    def fetch(self) -> int:
        """Fetch next instruction from memory."""
        if self.pc * 2 + 1 >= len(self.memory):
            self.halted = True
            return 0
        
        # Read 16-bit instruction (little-endian)
        low = self.memory[self.pc * 2]
        high = self.memory[self.pc * 2 + 1]
        instruction = (high << 8) | low
        
        return instruction
    
    def decode(self, instruction: int) -> tuple:
        """Decode instruction into components."""
        opcode = (instruction >> 12) & 0xF
        rd = (instruction >> 8) & 0xF
        rs1 = (instruction >> 4) & 0xF
        rs2 = instruction & 0xF
        imm = instruction & 0xFF
        
        return (opcode, rd, rs1, rs2, imm)
    
    def execute(self, instruction: int):
        """Execute a single instruction."""
        opcode, rd, rs1, rs2, imm = self.decode(instruction)
        
        # Ensure register indices are valid
        rd = rd & 0x7
        rs1 = rs1 & 0x7
        rs2 = rs2 & 0x7
        
        if opcode == 0x0:  # HALT
            self.halted = True
        
        elif opcode == 0x1:  # LOAD Rd, addr
            if imm < len(self.memory):
                self.registers[rd] = self.memory[imm]
            self.pc += 1
        
        elif opcode == 0x2:  # LOADI Rd, imm
            self.registers[rd] = imm
            self.pc += 1
        
        elif opcode == 0x3:  # STORE Rs, addr
            if imm < len(self.memory):
                self.memory[imm] = self.registers[rd] & 0xFF
            self.pc += 1
        
        elif opcode == 0x4:  # ADD Rd, Rs1, Rs2
            result = (self.registers[rs1] + self.registers[rs2]) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.negative_flag = (result & 0x80) != 0
            self.pc += 1
        
        elif opcode == 0x5:  # SUB Rd, Rs1, Rs2
            result = (self.registers[rs1] - self.registers[rs2]) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.negative_flag = (result & 0x80) != 0
            self.pc += 1
        
        elif opcode == 0x6:  # INC Rd
            result = (self.registers[rd] + 1) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.pc += 1
        
        elif opcode == 0x7:  # DEC Rd
            result = (self.registers[rd] - 1) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.pc += 1
        
        elif opcode == 0x8:  # AND Rd, Rs1, Rs2
            result = (self.registers[rs1] & self.registers[rs2]) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.pc += 1
        
        elif opcode == 0x9:  # OR Rd, Rs1, Rs2
            result = (self.registers[rs1] | self.registers[rs2]) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.pc += 1
        
        elif opcode == 0xA:  # XOR Rd, Rs1, Rs2
            result = (self.registers[rs1] ^ self.registers[rs2]) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.pc += 1
        
        elif opcode == 0xB:  # NOT Rd, Rs
            result = (~self.registers[rs1]) & 0xFF
            self.registers[rd] = result
            self.zero_flag = (result == 0)
            self.pc += 1
        
        elif opcode == 0xC:  # JMP addr
            self.pc = imm
        
        elif opcode == 0xD:  # JZ Rs, addr
            if self.registers[rd] == 0:
                self.pc = imm
            else:
                self.pc += 1
        
        elif opcode == 0xE:  # JNZ Rs, addr
            if self.registers[rd] != 0:
                self.pc = imm
            else:
                self.pc += 1
        
        elif opcode == 0xF:  # OUT Rs
            char = chr(self.registers[rd])
            self.output.append(char)
            print(char, end='', flush=True)
            self.pc += 1
        
        else:
            print(f"Unknown opcode: 0x{opcode:X}", file=sys.stderr)
            self.halted = True
    
    def run(self, max_instructions: int = 100000, debug: bool = False):
        """Run the program until HALT or max instructions."""
        self.halted = False
        self.instruction_count = 0
        
        while not self.halted and self.instruction_count < max_instructions:
            instruction = self.fetch()
            
            if debug:
                opcode = (instruction >> 12) & 0xF
                print(f"PC={self.pc:3d} | Inst=0x{instruction:04X} | "
                      f"R0={self.registers[0]:3d} | "
                      f"R1={self.registers[1]:3d}", file=sys.stderr)
            
            self.execute(instruction)
            self.instruction_count += 1
        
        if self.instruction_count >= max_instructions:
            print(f"\nExecution stopped: reached max instructions ({max_instructions})",
                  file=sys.stderr)
        
        if debug:
            print(f"\nExecution completed in {self.instruction_count} instructions",
                  file=sys.stderr)
    
    def get_output(self) -> str:
        """Get all output as a string."""
        return ''.join(self.output)
    
    def dump_state(self):
        """Dump current VM state (for debugging)."""
        print("\n=== VM State ===", file=sys.stderr)
        print(f"PC: {self.pc}", file=sys.stderr)
        print(f"Halted: {self.halted}", file=sys.stderr)
        print(f"Instructions executed: {self.instruction_count}", file=sys.stderr)
        print(f"Flags: Z={self.zero_flag} N={self.negative_flag}", file=sys.stderr)
        print("\nRegisters:", file=sys.stderr)
        for i in range(8):
            print(f"  R{i} = {self.registers[i]:3d} (0x{self.registers[i]:02X})",
                  file=sys.stderr)
        print(f"\nOutput: {repr(self.get_output())}", file=sys.stderr)


def load_binary(filename: str) -> List[int]:
    """Load binary machine code file."""
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Convert bytes to 16-bit instructions
    instructions = []
    for i in range(0, len(data), 2):
        if i + 1 < len(data):
            low = data[i]
            high = data[i + 1]
            instruction = (high << 8) | low
            instructions.append(instruction)
    
    return instructions


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python emulator.py <program.bin|program.asm> [--debug]")
        print("\nIf .asm file is provided, it will be assembled first.")
        sys.exit(1)
    
    input_file = sys.argv[1]
    debug = '--debug' in sys.argv
    
    # Create VM
    vm = VM()
    
    # Load program
    if input_file.endswith('.asm'):
        # Assemble first
        print("Assembling program...", file=sys.stderr)
        import os
        sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'assembly'))
        from assembler import Assembler
        
        assembler = Assembler()
        machine_code = assembler.assemble_file(input_file)
        vm.load_program(machine_code)
        
        if debug:
            print("\nDisassembly:", file=sys.stderr)
            print(assembler.disassemble(machine_code), file=sys.stderr)
            print("\nRunning program...\n", file=sys.stderr)
    else:
        # Load binary
        print("Loading binary...", file=sys.stderr)
        machine_code = load_binary(input_file)
        vm.load_program(machine_code)
    
    # Run program
    try:
        vm.run(debug=debug)
        
        if debug:
            vm.dump_state()
        
    except KeyboardInterrupt:
        print("\n\nExecution interrupted by user", file=sys.stderr)
        if debug:
            vm.dump_state()
    except Exception as e:
        print(f"\nExecution error: {e}", file=sys.stderr)
        if debug:
            vm.dump_state()
        raise
