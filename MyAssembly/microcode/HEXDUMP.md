# Microcode ROM Hexdump Analysis

Visual inspection of the microcode ROM binary showing the encoded control signals.

## Raw Hexdump (Canonical Format)

```
00000000  02 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 20 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |. ..............|
00000020  05 00 8a 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000030  05 00 0a 02 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000040  05 00 0e 00 88 00 00 00  00 00 00 00 00 00 00 00  |................|
00000050  05 00 0e 00 08 02 00 00  00 00 00 00 00 00 00 00  |................|
00000060  05 00 0e 00 10 01 00 00  00 00 00 00 00 00 00 00  |................|
00000070  05 00 0e 00 10 04 00 00  00 00 00 00 00 00 00 00  |................|
00000080  82 48 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |.H..............|
00000090  82 58 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |.X..............|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000c0  05 00 08 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000f0  02 01 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000100
```

## 16-bit Word View (Control Signal Format)

Each line shows 8 words (16 bytes). Our microcode uses 16-bit control words.

```
Address   Word0  Word1  Word2  Word3  Word4  Word5  Word6  Word7
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x0000:   0002   0000   0000   0000   0000   0000   0000   0000
0x0010:   2000   0000   0000   0000   0000   0000   0000   0000
0x0020:   0005   008a   0000   0000   0000   0000   0000   0000
0x0030:   0005   020a   0000   0000   0000   0000   0000   0000
0x0040:   0005   000e   0088   0000   0000   0000   0000   0000
0x0050:   0005   000e   0208   0000   0000   0000   0000   0000
0x0060:   0005   000e   0110   0000   0000   0000   0000   0000
0x0070:   0005   000e   0410   0000   0000   0000   0000   0000
0x0080:   4882   0000   0000   0000   0000   0000   0000   0000
0x0090:   5882   0000   0000   0000   0000   0000   0000   0000
0x00a0:   0000   0000   0000   0000   0000   0000   0000   0000
   *       (repeated zero pattern)
0x00c0:   0005   0008   0000   0000   0000   0000   0000   0000
0x00d0:   0000   0000   0000   0000   0000   0000   0000   0000
   *       (repeated zero pattern)
0x00f0:   0102   0000   0000   0000   0000   0000   0000   0000
```

## Decoded Instructions (Sample)

Correlating binary values with symbolic meanings:

### NOP (0x00) - Address 0x0000
```
T0: 0x0002 = PC_INC
    Just advance to next instruction
```

### HALT (0x01) - Address 0x0010
```
T0: 0x2000 = HALT
    Stop execution
```

### LDI_A (0x02) - Address 0x0020-0x0022
```
T0: 0x0005 = PC_OUT | MAR_IN
    Point to immediate value
    
T1: 0x008a = IR_OUT | A_IN | RAM_OUT
    Load value into register A
```

### ADD (0x08) - Address 0x0080
```
T0: 0x4882 = FLAGS_IN | ALU_OUT | A_IN | PC_INC
    Compute A+B, store in A, update flags, advance PC
```

### SUB (0x09) - Address 0x0090
```
T0: 0x5882 = FLAGS_IN | ALU_SUB | ALU_OUT | A_IN | PC_INC
    Compute A-B, store in A, update flags, advance PC
```

### OUT_A (0x0F) - Address 0x00F0
```
T0: 0x0102 = A_OUT | PC_INC
    Output register A to display/console
```

## Structure Notes

- **256 bytes total** (128 x 16-bit words)
- **Little-endian format** (LSB first)
- **Each instruction occupies 16 bytes** (8 words, max 3 used for micro-steps)
- **Instruction address** = opcode Ã— 16
- **Micro-step address** = (opcode Ã— 16) + (step Ã— 2)

## The Recursion

This hexdump was generated by a computer (your Linux system) to inspect the binary that defines another computer (MinimumCompute). That computer could theoretically run a hexdump program to inspect itself.

**Computers inspecting computers all the way down.** ğŸ¢ğŸ’»âˆ

---

*Generated: November 19, 2025*  
*Source: microcode.bin (256 bytes)*  
*Format: AT28C16 EEPROM compatible*
